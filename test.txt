const Editor = @This();
const std = @import("std");
const posix = std.posix;
const ascii = std.ascii;

const stdin = std.fs.File.stdin();
const stdout = std.fs.File.stdout();
const Allocator = std.mem.Allocator;

alloc: Allocator,
stdin_fs_reader: std.fs.File.Reader = undefined,
stdout_fs_writer: std.fs.File.Writer = undefined,
reader: *std.io.Reader,
writer: *std.io.Writer,
origTermios: ?posix.termios = null,
winSize: posix.winsize = .{
    .row = 0,
    .col = 0,
    .xpixel = 0,
    .ypixel = 0,
},
cursorPosition: CursorPosition = CursorPosition{ .x = 0, .y = 0 },
numRows: usize = 0,
rows: std.ArrayList(Row),
stdin_buffer: [4096]u8,
stdout_buffer: [4096]u8,

const CursorPosition = struct { x: usize, y: usize };
const Row = struct {
    chars: []u8,
};

const EditorKey = union(enum) {
    cursor: CursorKey,
    notImpl: void,
    quit: void,
    esc: void,
    none: void,
    page_up: void,
    page_down: void,
    home_key: void,
    end_key: void,
    delete_key: void,
};

const CursorKey = enum(u8) {
    up = 'k',
    down = 'j',
    left = 'h',
    right = 'l',
};

pub fn init(alloc: Allocator) !Editor {
    var editor = Editor{
        .alloc = alloc,
        .origTermios = null,
        .winSize = .{ .row = 0, .col = 0, .xpixel = 0, .ypixel = 0 },
        .cursorPosition = CursorPosition{ .x = 0, .y = 0 },
        .numRows = 0,
        .rows = try std.ArrayList(Row).initCapacity(alloc, 0),
        .stdin_buffer = undefined,
        .stdout_buffer = undefined,
        .reader = undefined,
        .writer = undefined,
    };

    editor.stdin_fs_reader = std.fs.File.stdin().reader(&editor.stdin_buffer);
    editor.stdout_fs_writer = std.fs.File.stdout().writer(&editor.stdout_buffer);

    editor.reader = &editor.stdin_fs_reader.interface;
    editor.writer = &editor.stdout_fs_writer.interface;

    return editor;
}

pub fn deinit(self: *Editor) void {
    for (self.rows.items) |row| {
        if (row.chars.len > 0) {
            self.alloc.free(row.chars);
        }
    }
    self.rows.deinit(self.alloc);
}

pub fn open(self: *Editor, file: std.fs.File) !void {
    var file_buf: [4096]u8 = undefined;
    var file_reader = file.reader(&file_buf);
    const reader = &file_reader.interface;

    while (reader.takeDelimiterExclusive('\n')) |line| {
        const new_row_chars = try self.alloc.dupe(u8, line);
        try self.rows.append(self.alloc, Row{ .chars = new_row_chars });
    } else |err| switch (err) {
        error.EndOfStream,
        error.StreamTooLong,
        error.ReadFailed,
        => {},
    }

    if (self.rows.items.len == 0) {
        try self.rows.append(self.alloc, Row{ .chars = &[_]u8{} });
    }

    self.numRows = self.rows.items.len;
}

fn ctrlKey(char: u8) u8 {
    return (char) & 0x1f;
}

pub fn run(self: *Editor) !void {
    try self.enableRawMode();
    try self.updateWindowSize();

    while (true) {
        try self.refreshScreen();
        var key: EditorKey = undefined;

        key = self.readKey() catch EditorKey{ .none = {} };
        if (key == .none) {
            continue;
        }
        if (key == .quit) {
            break;
        }
        self.processKey(key);
    }

    try self.write("\x1b[2J");
    try self.write("\x1b[H");

    try self.disableRawMode();
}

fn processKey(self: *Editor, key: EditorKey) void {
    switch (key) {
        .cursor => |cursor| self.processCursorKey(cursor),
        else => {},
    }
}

fn processCursorKey(self: *Editor, key: CursorKey) void {
    switch (key) {
        .left => {
            if (self.cursorPosition.x != 0) {
                self.cursorPosition.x = self.cursorPosition.x - 1;
            }
        },
        .right => {
            if (self.winSize.col - 1 != self.cursorPosition.x) {
                self.cursorPosition.x = self.cursorPosition.x + 1;
            }
        },
        .up => {
            if (self.cursorPosition.y != 0) {
                self.cursorPosition.y = self.cursorPosition.y - 1;
            }
        },
        .down => {
            if (self.winSize.row - 1 != self.cursorPosition.y) {
                self.cursorPosition.y = self.cursorPosition.y + 1;
            }
        },
    }
}

pub fn enableRawMode(self: *Editor) !void {
    var termios: posix.termios = undefined;
    termios = try posix.tcgetattr(stdin.handle);
    self.origTermios = termios;

    termios.iflag.BRKINT = false;
    termios.iflag.ICRNL = false;
    termios.iflag.INPCK = false;
    termios.iflag.ISTRIP = false;
    termios.iflag.IXON = false;
    termios.iflag.IUTF8 = false;

    termios.oflag.OPOST = false;

    termios.cflag.CSIZE = std.posix.CSIZE.CS8;

    termios.lflag.ECHO = false;
    termios.lflag.ICANON = false;
    termios.lflag.IEXTEN = false;
    termios.lflag.ISIG = false;

    termios.cc[@intFromEnum(posix.V.MIN)] = 0;
    termios.cc[@intFromEnum(posix.V.TIME)] = 1;

    try posix.tcsetattr(stdin.handle, posix.TCSA.NOW, termios);
}

pub fn disableRawMode(self: *Editor) !void {
    if (self.origTermios) |termios| {
        try self.flush();
        try posix.tcsetattr(stdin.handle, posix.TCSA.NOW, termios);
    }
}

pub fn write(self: *Editor, bytes: []const u8) !void {
    try self.writer.writeAll(bytes);
}

pub fn flush(self: *Editor) !void {
    try self.writer.flush();
}

pub fn refreshScreen(self: *Editor) !void {
    try self.write("\x1b[?25l");
    try self.write("\x1b[H");
    try self.drawRows();
    try self.writer.print("\x1b[{};{}H", .{ self.cursorPosition.y + 1, self.cursorPosition.x + 1 });
    try self.write("\x1b[?25h");
    try self.flush();
}

pub fn drawRows(self: *Editor) !void {
    var y: usize = 0;
    while (y < self.winSize.row) : (y += 1) {
        if (y >= self.numRows) {
            if (self.numRows == 0 and y == self.winSize.row / 3) {
                const welcome = "Welcome to Kilo editor";
                var padding = (self.winSize.col - welcome.len) / 2;
                try self.write("~");
                padding = padding - 1;
                while (padding > 0) {
                    try self.write(" ");
                    padding = padding - 1;
                }
                try self.write(welcome);
            } else {
                try self.write("~");
            }
        } else {
            const currentRow = self.rows.items[y];
            var len = currentRow.chars.len;
            if (len > self.winSize.col) {
                len = self.winSize.col;
            }
            try self.write(currentRow.chars[0..len]);
        }
        try self.write("\x1b[K");
        if (y < self.winSize.row - 1) {
            try self.write("\r\n");
        }
    }
}

pub fn updateWindowSize(self: *Editor) !void {
    var winSize: posix.winsize = undefined;
    const rc = posix.system.ioctl(stdin.handle, posix.T.IOCGWINSZ, @intFromPtr(&winSize));
    if (std.posix.errno(rc) == .SUCCESS) {
        self.winSize = winSize;
    }
}

pub fn readKey(self: *Editor) !EditorKey {
    const char: u8 = try self.reader.takeByte();
    var key: EditorKey = undefined;

    switch (char) {
        'k', 'j', 'h', 'l' => key = EditorKey{ .cursor = @enumFromInt(char) },
        '\x1b' => {
            const next_char_result = self.reader.takeByte();

            if (next_char_result == error.EndOfStream) {
                return EditorKey{ .quit = {} };
            }

            const next_char = try next_char_result;

            if (next_char == '[') {
                const third_char_result = self.reader.takeByte();
                if (third_char_result == error.EndOfStream) {
                    return EditorKey{ .notImpl = {} };
                }
                const third_char = try third_char_result;

                switch (third_char) {
                    'A' => key = EditorKey{ .cursor = CursorKey.up },
                    'B' => key = EditorKey{ .cursor = CursorKey.down },
                    'C' => key = EditorKey{ .cursor = CursorKey.right },
                    'D' => key = EditorKey{ .cursor = CursorKey.left },
                    'H' => key = EditorKey{ .home_key = {} },
                    'F' => key = EditorKey{ .end_key = {} },
                    '1', '2', '3', '4', '5', '6' => {
                        const fourth_char_result = self.reader.takeByte();
                        if (fourth_char_result == error.EndOfStream) {
                            return EditorKey{ .notImpl = {} };
                        }
                        const fourth_char = try fourth_char_result;

                        if (fourth_char == '~') {
                            switch (third_char) {
                                '1' => key = EditorKey{ .home_key = {} },
                                '3' => key = EditorKey{ .delete_key = {} },
                                '4' => key = EditorKey{ .end_key = {} },
                                '5' => key = EditorKey{ .page_up = {} },
                                '6' => key = EditorKey{ .page_down = {} },
                                else => key = EditorKey{ .notImpl = {} },
                            }
                        } else {
                            key = EditorKey{ .notImpl = {} };
                        }
                    },
                    else => key = EditorKey{ .notImpl = {} },
                }
            } else {
                key = EditorKey{ .quit = {} };
            }
        },
        else => {
            if (char == ctrlKey('q')) {
                key = EditorKey{ .quit = {} };
            } else {
                key = EditorKey{ .notImpl = {} };
            }
        },
    }
    return key;
}

